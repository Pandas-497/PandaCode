<!DOCTYPE html>
<head>
    <title>PandaCode</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="favicon.png">
    <meta charset="utf-8">
    <meta name="author" content="Team Pandas">
    <meta name="description" content="Learn web programming!">
    <meta property="og:type" content="website">
    <meta property="og:title" content="PandaCode">
    <meta property="og:description" content="Learn web programming!">
    <meta property="og:image" content="favicon.png">
    <div style="display:none;">
        <img id="binImg" src="bin.png">
        <img id="binWhiteImg" src="binWhite.png">
    </div>
    <script src="CanvasInput.js"></script>
    <script>
        window.requestAnimFrame = (function(){
            // Glue code found on stackoverflow :)
            return window.requestAnimationFrame       
                || window.webkitRequestAnimationFrame 
                || window.mozRequestAnimationFrame    
                || ((callback) => window.setTimeout(callback, 1000 / 60));
        })();
      
        window.onload = () => {
            let theCanvas = document.getElementById("ui-canvas");

            var htmlInput = "<title>input</title>";
    
            function fitToContainer(canvas){
                // Make it visually fill the positioned parent
                canvas.style.width ='100%';
                canvas.style.height='100%';
                // ...then set the internal size to match
                canvas.width  = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            let thePreview = document.getElementById("preview");
            let theHTML = document.getElementById("html");

            // Tracking mouse position. We can use mouse.x and mouse.y to get
            // mouse coordinates within to the canvas.
            let dragFrom = { x: 0, y: 0 };
            let mouse = { x: 0, y: 0 };
            theCanvas.onmousemove = (e) => {
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            };
            function isMouseIn(x, y, w, h) {
                return mouse.x >= x && mouse.y >= y 
                    && mouse.x <= x + w && mouse.y <= y + h;
            }

            let tags = [];
            let elements = [];

            class Tag {
                constructor(name, tag, color, hasInput = true, tagclass = Element) {
                    this.name = name;
                    this.tag = tag;
                    this.tagclass = tagclass;
                    this.color = color;
                    this.hasInput = hasInput;
                }

                hovered(i) {
                    let x = 8;
                    let y = i * 48 + 8;
                    return mouse.x >= x && mouse.y >= y && mouse.x <= x + 112 && mouse.y <= y + 40;
                }

                createElement(i, canvas) {
                    return new this.tagclass(240, 120, this, canvas);
                }

                draw(i, ctx) {
                    // Compute position for ith button.
                    let x = 8;
                    let y = i * 48 + 8;

                    // Draw button background.
                    ctx.fillStyle = this.color;
                    let hovering = this.hovered(i);
                    ctx.fillRect(hovering ? x - 2 : x, hovering ? y - 2 : y, hovering ? 116 : 112, hovering ? 44 : 40);
                    
                    // Draw button label.
                    ctx.font = "12pt Montserrat";
                    ctx.fillStyle = "white";
                    ctx.fillText(`${this.name}`, x + 8, y + 24);
                }
            }

            const CLASS_PLACEHOLDER = "placeholder",
                  CLASS_PARAGRAPH = "paragraph",
                  CLASS_INLINE = "inline";

            class Element {
                constructor(w, h, button, canvas) {
                    this.elementclass = button == undefined ? CLASS_PLACEHOLDER : CLASS_PARAGRAPH;
                    this.button = button;
                    this.w = w;
                    this.h = h;
                    this.input = this.elementclass == CLASS_PLACEHOLDER ? undefined : new CanvasInput({
                        canvas: canvas,
                        width: w - 28,
                        height: 24,
                        borderRadius: 0,
                        borderColor: "white",
                        boxShadow: "0px 0px 0px 0px",
                        innerShadow: "0px 0px 0px 0px"
                    });
                }

                height() {
                    if (this.elementclass == CLASS_PLACEHOLDER) return this.h;
                    else if (this.elementclass == CLASS_PARAGRAPH) return 56 + this.input.height();
                }

                hovered(x, y) {
                    return mouse.x >= x && mouse.y >= y && mouse.x <= x + this.w && mouse.y <= y + this.height();
                }

                draw(x, y, ctx) {
                    if (this.elementclass == CLASS_PLACEHOLDER) {
                        ctx.fillStyle = "gray";
                        ctx.fillRect(x + 2, y + 2, this.w - 4, this.height() - 4);
                        return;
                    }

                    ctx.fillStyle = this.button.color;
                    if (this.hovered(x, y)) ctx.fillRect(x - 2, y - 2, this.w + 4, this.height() + 4);
                    else ctx.fillRect(x, y, this.w, this.height());
                    this.input._x = x + 8;
                    this.input._y = y + 28;
                    this.input.render(ctx);
                    ctx.font = "10pt Montserrat";
                    ctx.fillStyle = "white";
                    ctx.fillText(`<${this.button.tag}>`, x + 8, y + 19);
                    ctx.font = "10pt Montserrat";
                    ctx.fillStyle = "white";
                    ctx.fillText(`</${this.button.tag}>`, x + 8, y + 47 + this.input.height());
                }

                html() {
                    return `<${this.button.tag}>${this.input.value()}</${this.button.tag}>`;
                }
            }

            function iterateElements(callable) {                
                let x = 140;
                let y = 8;
                for (let i = 0; i < elements.length; i ++) {
                    callable(elements[i], x, y);
                    y += elements[i].height() + 8;
                }
            }

            function removeElement(element) {
                elements.splice(elements.indexOf(element), 1);
            }

            let isMouseDown = false;
            theCanvas.onmousedown = (e) => {
                isMouseDown = true;
            }

            theCanvas.onmouseup = (e) => {
                isMouseDown = false;
                if (draggedElement == undefined) {
                    for (let i = 0; i < tags.length; i ++) {
                        if (tags[i].hovered(i)) elements.push(tags[i].createElement(i, theCanvas));
                    }
                }
            }

            class Link extends Element {
                html() {
                    return `<p><${this.button.tag} href=\"${this.input.value()}\">${this.input.value()}</${this.button.tag}></p>`;
                }
            }

            class Image extends Element {
                html() {
                    return `<${this.button.tag} src=${this.input.value()}>`;
                }
            }

            { // init
                tags.push(new Tag("header", "h1", "blue"));
                tags.push(new Tag("paragraph", "p", "green"));
                tags.push(new Tag("link", "a", "magenta", true, Link));
                tags.push(new Tag("image", "img", "red", true, Image));
            };

            let draggedElement = undefined;
            let dragPoint = { x: 0, y: 0 };
            let dragOffset = { x: 0, y: 0 };
            function update() {
                if (!isMouseDown) dragPoint.x = mouse.x, dragPoint.y = mouse.y;

                // Handle dragging elements.
                if (draggedElement == undefined && Math.hypot(mouse.x - dragPoint.x, mouse.y - dragPoint.y) > 16) { 
                    let found = false;
                    // Attempt click for every tag button.
                    for (let i = 0; i < tags.length; i ++) {
                        if (tags[i].hovered(i)) {
                            found = true;
                            draggedElement = tags[i].createElement(i, theCanvas);
                            dragOffset.x = mouse.x - 8;
                            dragOffset.y = mouse.y - (8 + i * 48);
                        }
                    }
                    if (!found) iterateElements((e, x, y) => { // Find first targeted element
                        if (e.hovered(x, y) && !found) {
                            found = true;
                            draggedElement = e;
                            dragOffset.x = mouse.x - x;
                            dragOffset.y = mouse.y - y;
                        }
                    });
                    if (draggedElement != undefined) {
                        elements[elements.indexOf(draggedElement)] = new Element(draggedElement.w, draggedElement.height());
                    }
                }

                if (draggedElement != undefined) {
                    if (mouse.x > 96 && isMouseIn(0, 0, theCanvas.width, theCanvas.height)) { // if it's in the element area
                        elements = elements.filter((v) => v.elementclass != CLASS_PLACEHOLDER);
                        let i = 0;
                        iterateElements((e, x, y) => {
                            if (y < mouse.y - dragOffset.y) i ++;
                        });
                        if (!isMouseDown) {
                            if (!isMouseIn(theCanvas.width - 80, theCanvas.height - 80, 80, 80)) // if not over trash can
                                elements.splice(i, 0, draggedElement);
                            draggedElement = undefined;
                            dragOffset.x = 0;
                            dragOffset.y = 0;
                        }
                        else {
                            elements.splice(i, 0, new Element(draggedElement.w, draggedElement.height()));
                        }
                    }
                }
            }

            function render(ctx) {
                // Example render behavior. We'll want to replace the button rendering
                // with something more sophisticated in the future.
                fitToContainer(theCanvas);
                
                // Clear canvas to start a new frame.
                ctx.clearRect(0, 0, ctx.width, ctx.height);

                // Draw trash can.
                let trashHover = draggedElement != undefined && isMouseIn(theCanvas.width - 80, theCanvas.height - 80, 80, 80);
                if (trashHover) {
                    ctx.fillStyle = "black";
                    ctx.beginPath();
                    ctx.arc(theCanvas.width - 40, theCanvas.height - 40, 36, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.drawImage(document.getElementById(trashHover ? "binWhiteImg" : "binImg"), theCanvas.width - 64, theCanvas.height - 64, 48, 48);

                // Draw elements.
                iterateElements((e, x, y) => e.draw(x, y, ctx));

                // Draw dragged element, if any.
                if (draggedElement != undefined) {
                    draggedElement.draw(mouse.x - dragOffset.x, mouse.y - dragOffset.y, ctx);
                }

                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, 128, theCanvas.height);
                ctx.fillStyle = "black";
                ctx.fillRect(128, 0, 2, theCanvas.height);

                // Draw tag buttons.
                for (let i = 0; i < tags.length; i ++) {
                    tags[i].draw(i, ctx);
                }
            }

            let downloadTab = document.getElementById("download-tab");
            downloadTab.onclick = (e) => {
                var html = thePreview.innerHTML;
                var link = document.createElement('a');
                var fileName = 'pandaCode.html';

                link.setAttribute('download', fileName);
                link.setAttribute('href', 'data:text/plain;charset=utf-8, ' + encodeURIComponent(html));
                link.click();
            }
            let previewTab = document.getElementById("preview-tab");
            // const fs = require('fs');
            previewTab.onclick = (e) => {
                // fs.writeFile('input.html', htmlInput, (err) => {
                //     if(err) throw err;
                // });

                let html = document.getElementById('html');
                let preview = document.getElementById('preview');

                if (html.style.display == 'block') {
                    html.style.display = 'none'
                    preview.style.display = 'block'
                }
            }
            let htmlTab = document.getElementById("html-tab");
            htmlTab.onclick = (e) => {
                let html = document.getElementById('html');
                let preview = document.getElementById('preview');

                if (preview.style.display == 'block') {
                    preview.style.display = 'none'
                    html.style.display = 'block'
                }
            }
            
            (function renderFrame() {
                requestAnimationFrame(renderFrame);
                update();
                render(theCanvas.getContext("2d"));
            })();

            function escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            function updatePreview() {
                let preview = "", html = "";
                for (let element of elements) {
                    let encoded = element.html();
                    preview += encoded;
                    html += escapeHtml(encoded);
                }
                thePreview.innerHTML = preview;
                theHTML.innerHTML = html;
            }

            setInterval(updatePreview, 1000);
        }
    </script>
</head>
<body>
    <div>
        <div style="display: inline-block; vertical-align: middle;">
            <img src="favicon.png" width="96px" height="96px">
        </div>  
        <div style="display: inline-block; vertical-align: middle;">
            <h1> Panda<span class="code-title">Code</span> </h1>
        </div>
    </div>
    <div class="panels">
        <div class="panel" id="layout-panel">
            <span class="panel-title">Layout</span><br>
            <canvas id="ui-canvas">
                <!-- Our GUI will be implemented in this canvas element. -->
            </canvas>
        </div><div class="panel" id="display-panel">
            <span class="panel-title">Display</span>
            <span class="panel-tab" id="download-tab">Download</span>
            <span class="panel-tab" id="preview-tab">Preview</span>
            <span class="panel-tab" id="html-tab">HTML</span><br>
            <div class="html-display">
                <div class="scrollbox">
                    <div class="display-body" id="preview" style="display: block">
                        <!-- 
                            Whatever site preview we want should
                            go in the innerHtml of this div. 
                        -->
                    </div>
                    <div class="display-body" id="html" style="display: none"></div>
                        <!-- 
                            Whatever code display we want should
                            go in the innerHtml of this div. 
                        -->
                </div>
            </div>
        </div>
    </div>
</body>
